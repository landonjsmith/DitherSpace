<!DOCTYPE html>
<html lang="en">
<head>
    <!--Copyright (c) 2025 Landon J. Smith

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DitherSpace</title>
</head>
<body>
    <h1>DitherSpace (v1.0)</h1>
    An open-source clone of the cyberspace.online image dithering algorithm.
    Source code is available on <a href="https://github.com/landonjsmith/DitherSpace">GitHub</a>.
    (C) 2025 Landon J Smitth | <a href="https://landonjsmith.com">Home</a>
    <hr>
    
    <h2>Load An Image</h2>
    <input type="file" id="imageInput" accept="image/*">
    <button onclick="loadSampleImage()">Load Test Image</button>
    
    <hr>
    
    <h2>Controls</h2>
    
    <p>
        <b>Pixel Size:</b> <span id="pixelSizeValue">4</span>
        <input type="range" id="pixelSize" min="1" max="20" value="4" step="1">
    </p>
    
    <p>
        <b>Dither Amount:</b> <span id="ditherAmountValue">0.75</span>
        <input type="range" id="ditherAmount" min="0" max="1" value="0.75" step="0.05">
    </p>
    
    <p>
        <b>Bit Depth:</b> <span id="bitDepthValue">2</span>
        <input type="range" id="bitDepth" min="1" max="8" value="2" step="1">
    </p>
    
    <p>
        <b>Contrast:</b> <span id="contrastValue">1.0</span>
        <input type="range" id="contrast" min="0.5" max="2" value="1" step="0.1">
    </p>
    
    <p>
        <b>Scale:</b> <span id="scaleValue">1.0</span>
        <input type="range" id="scale" min="0.1" max="2" value="1" step="0.1">
    </p>
    <p>
        <b>Foreground Color:</b>
        <input type="color" id="fgColor" value="#000000">
    </p>
    <p>
        <b>Background Color:</b>
        <input type="color" id="bgColor" value="#ffffff">
    </p>
    <hr>
    
    <h2>Image Output</h2>
    <canvas id="canvas"></canvas>
    
    <p>
        <button onclick="exportImage()">Export Dithered Image</button>
    </p>

    <script>
        class ImageDitherer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.gl = null;
                this.program = null;
                this.texture = null;
                this.positionBuffer = null;
                this.texCoordBuffer = null;
                this.originalWidth = 800;
                this.originalHeight = 600;
                
                this.params = {
                    pixelSize: 4,
                    ditherAmount: 0.75,
                    bitDepth: 2,
                    contrast: 1.0,
                    scale: 1.0,
                    fgColor: '#000000',
                    bgColor: '#ffffff'
                };

                this.initWebGL();
            }

            initWebGL() {
                this.gl = this.canvas.getContext('webgl', { preserveDrawingBuffer: true });
                if (!this.gl) {
                    alert('WebGL not supported in your browser');
                    return;
                }

                const vertexShaderSource = `
                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                        v_texCoord = a_texCoord;
                    }
                `;

                const fragmentShaderSource = `
                    precision mediump float;
                    
                    uniform sampler2D u_image;
                    uniform vec2 u_resolution;
                    uniform float u_pixelSize;
                    uniform float u_ditherAmount;
                    uniform float u_bitDepth;
                    uniform float u_contrast;
                    uniform vec3 u_fgColor;
                    uniform vec3 u_bgColor;
                    
                    varying vec2 v_texCoord;
                    
                    float bayer8x8(vec2 pos) {
                        int x = int(mod(pos.x, 8.0));
                        int y = int(mod(pos.y, 8.0));
                        int idx = y * 8 + x;
                        
                        if (idx == 0) return 0.0 / 64.0;
                        else if (idx == 1) return 32.0 / 64.0;
                        else if (idx == 2) return 8.0 / 64.0;
                        else if (idx == 3) return 40.0 / 64.0;
                        else if (idx == 4) return 2.0 / 64.0;
                        else if (idx == 5) return 34.0 / 64.0;
                        else if (idx == 6) return 10.0 / 64.0;
                        else if (idx == 7) return 42.0 / 64.0;
                        else if (idx == 8) return 48.0 / 64.0;
                        else if (idx == 9) return 16.0 / 64.0;
                        else if (idx == 10) return 56.0 / 64.0;
                        else if (idx == 11) return 24.0 / 64.0;
                        else if (idx == 12) return 50.0 / 64.0;
                        else if (idx == 13) return 18.0 / 64.0;
                        else if (idx == 14) return 58.0 / 64.0;
                        else if (idx == 15) return 26.0 / 64.0;
                        else if (idx == 16) return 12.0 / 64.0;
                        else if (idx == 17) return 44.0 / 64.0;
                        else if (idx == 18) return 4.0 / 64.0;
                        else if (idx == 19) return 36.0 / 64.0;
                        else if (idx == 20) return 14.0 / 64.0;
                        else if (idx == 21) return 46.0 / 64.0;
                        else if (idx == 22) return 6.0 / 64.0;
                        else if (idx == 23) return 38.0 / 64.0;
                        else if (idx == 24) return 60.0 / 64.0;
                        else if (idx == 25) return 28.0 / 64.0;
                        else if (idx == 26) return 52.0 / 64.0;
                        else if (idx == 27) return 20.0 / 64.0;
                        else if (idx == 28) return 62.0 / 64.0;
                        else if (idx == 29) return 30.0 / 64.0;
                        else if (idx == 30) return 54.0 / 64.0;
                        else if (idx == 31) return 22.0 / 64.0;
                        else if (idx == 32) return 3.0 / 64.0;
                        else if (idx == 33) return 35.0 / 64.0;
                        else if (idx == 34) return 11.0 / 64.0;
                        else if (idx == 35) return 43.0 / 64.0;
                        else if (idx == 36) return 1.0 / 64.0;
                        else if (idx == 37) return 33.0 / 64.0;
                        else if (idx == 38) return 9.0 / 64.0;
                        else if (idx == 39) return 41.0 / 64.0;
                        else if (idx == 40) return 51.0 / 64.0;
                        else if (idx == 41) return 19.0 / 64.0;
                        else if (idx == 42) return 59.0 / 64.0;
                        else if (idx == 43) return 27.0 / 64.0;
                        else if (idx == 44) return 49.0 / 64.0;
                        else if (idx == 45) return 17.0 / 64.0;
                        else if (idx == 46) return 57.0 / 64.0;
                        else if (idx == 47) return 25.0 / 64.0;
                        else if (idx == 48) return 15.0 / 64.0;
                        else if (idx == 49) return 47.0 / 64.0;
                        else if (idx == 50) return 7.0 / 64.0;
                        else if (idx == 51) return 39.0 / 64.0;
                        else if (idx == 52) return 13.0 / 64.0;
                        else if (idx == 53) return 45.0 / 64.0;
                        else if (idx == 54) return 5.0 / 64.0;
                        else if (idx == 55) return 37.0 / 64.0;
                        else if (idx == 56) return 63.0 / 64.0;
                        else if (idx == 57) return 31.0 / 64.0;
                        else if (idx == 58) return 55.0 / 64.0;
                        else if (idx == 59) return 23.0 / 64.0;
                        else if (idx == 60) return 61.0 / 64.0;
                        else if (idx == 61) return 29.0 / 64.0;
                        else if (idx == 62) return 53.0 / 64.0;
                        else return 21.0 / 64.0;
                    }
                    
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        vec2 uv = v_texCoord;
                        
                        vec2 pixelatedUV = floor(uv * u_resolution / u_pixelSize) * u_pixelSize / u_resolution;
                        
                        vec4 color = texture2D(u_image, pixelatedUV);
                        
                        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        
                        gray = (gray - 0.5) * u_contrast + 0.5;
                        gray = clamp(gray, 0.0, 1.0);
                        
                        vec2 pixelPos = floor(gl_FragCoord.xy);
                        float bayerValue = bayer8x8(pixelPos);
                        
                        float noise = random(pixelPos * 0.01) * 0.1;
                        bayerValue = mix(bayerValue, noise, 0.3);
                        
                        float threshold = mix(0.5, bayerValue, u_ditherAmount);
                        float dithered = step(threshold, gray);
                        
                        float levels = pow(2.0, u_bitDepth);
                        float quantized = floor(gray * levels) / levels;
                        
                        float final = mix(quantized, dithered, u_ditherAmount);
                        
                        vec3 finalColor = mix(u_bgColor, u_fgColor, final);
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `;

                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);

                if (!vertexShader || !fragmentShader) return;

                this.program = this.createProgram(vertexShader, fragmentShader);
                if (!this.program) return;

                this.positionBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1,
                ]), this.gl.STATIC_DRAW);

                this.texCoordBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                    0, 1,
                    1, 1,
                    0, 0,
                    1, 0,
                ]), this.gl.STATIC_DRAW);

                this.texture = this.gl.createTexture();
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                if (!shader) return null;

                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            createProgram(vertexShader, fragmentShader) {
                const program = this.gl.createProgram();
                if (!program) return null;

                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking error:', this.gl.getProgramInfoLog(program));
                    this.gl.deleteProgram(program);
                    return null;
                }
                return program;
            }

            loadImage(src) {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    this.originalWidth = img.width;
                    this.originalHeight = img.height;

                    this.updateCanvasSize();

                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
                    
                    this.render();
                };
                img.onerror = () => {
                    alert('Failed to load image: ' + src);
                };
                img.src = src;
            }

            updateCanvasSize() {
                this.canvas.width = Math.floor(this.originalWidth * this.params.scale);
                this.canvas.height = Math.floor(this.originalHeight * this.params.scale);
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (!result) return [0, 0, 0];

                return [
                    parseInt(result[1], 16) / 255,
                    parseInt(result[2], 16) / 255,
                    parseInt(result[3], 16) / 255
                ];
            }

            render() {
                if (!this.gl || !this.program) return;

                this.gl.useProgram(this.program);

                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);

                const texCoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
                this.gl.enableVertexAttribArray(texCoordLocation);
                this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);

                this.gl.uniform2f(
                    this.gl.getUniformLocation(this.program, 'u_resolution'),
                    this.canvas.width,
                    this.canvas.height
                );

                this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_pixelSize'), this.params.pixelSize);
                this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_ditherAmount'), this.params.ditherAmount);
                this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_bitDepth'), this.params.bitDepth);
                this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_contrast'), this.params.contrast);

                const fgColor = this.hexToRgb(this.params.fgColor);
                const bgColor = this.hexToRgb(this.params.bgColor);

                this.gl.uniform3f(this.gl.getUniformLocation(this.program, 'u_fgColor'), fgColor[0], fgColor[1], fgColor[2]);
                this.gl.uniform3f(this.gl.getUniformLocation(this.program, 'u_bgColor'), bgColor[0], bgColor[1], bgColor[2]);

                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }

            updateParams(newParams) {
                const needsResize = newParams.scale !== undefined && newParams.scale !== this.params.scale;
                
                Object.assign(this.params, newParams);
                
                if (needsResize) {
                    this.updateCanvasSize();
                }
                
                this.render();
            }
        }

        var ditherer = new ImageDitherer('canvas');

        var controls = {
            pixelSize: document.getElementById('pixelSize'),
            ditherAmount: document.getElementById('ditherAmount'),
            bitDepth: document.getElementById('bitDepth'),
            contrast: document.getElementById('contrast'),
            scale: document.getElementById('scale'),
            fgColor: document.getElementById('fgColor'),
            bgColor: document.getElementById('bgColor'),
            imageInput: document.getElementById('imageInput')
        };

        var valueDisplays = {
            pixelSize: document.getElementById('pixelSizeValue'),
            ditherAmount: document.getElementById('ditherAmountValue'),
            bitDepth: document.getElementById('bitDepthValue'),
            contrast: document.getElementById('contrastValue'),
            scale: document.getElementById('scaleValue')
        };

        function setupControl(key) {
            if (key === 'imageInput') return;
            
            controls[key].addEventListener('input', function(e) {
                var value = e.target.type === 'color' ? e.target.value : parseFloat(e.target.value);
                
                if (valueDisplays[key]) {
                    valueDisplays[key].textContent = value;
                }
                
                var params = {};
                params[key] = value;
                ditherer.updateParams(params);
            });
        }

        for (var key in controls) {
            setupControl(key);
        }

        controls.imageInput.addEventListener('change', function(e) {
            var file = e.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(event) {
                    ditherer.loadImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        function loadSampleImage() {
            var tempCanvas = document.createElement('canvas');
            tempCanvas.width = 400;
            tempCanvas.height = 400;
            var ctx = tempCanvas.getContext('2d');
            
            var gradient = ctx.createRadialGradient(200, 200, 0, 200, 200, 200);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#888888');
            gradient.addColorStop(1, '#000000');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 400, 400);
            
            for (var i = 0; i < 20; i++) {
                var x = Math.random() * 400;
                var y = Math.random() * 400;
                var r = Math.random() * 30 + 10;
                var opacity = Math.random() * 0.5 + 0.3;
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(' + Math.floor(Math.random() * 255) + ', ' + 
                               Math.floor(Math.random() * 255) + ', ' + 
                               Math.floor(Math.random() * 255) + ', ' + opacity + ')';
                ctx.fill();
            }
            
            ditherer.loadImage(tempCanvas.toDataURL());
        }

        function exportImage() {
            var canvas = document.getElementById('canvas');
            if (canvas.width === 0 || canvas.height === 0) {
                alert('No image loaded. Please load an image first.');
                return;
            }
            var link = document.createElement('a');
            link.download = 'dithered-image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        loadSampleImage();
    </script>
</body>
</html>